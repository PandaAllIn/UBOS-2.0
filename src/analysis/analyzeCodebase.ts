/**
 * UBOS Codebase Analysis CLI
 * Run comprehensive analysis and generate organization report
 */

import { codebaseAnalyzer, CodebaseOverview } from './codebaseAnalyzer.js';
import { promises as fs } from 'fs';
import path from 'path';

interface AnalysisReport {
  overview: CodebaseOverview;
  timestamp: string;
  recommendations: {
    cleanup: string[];
    organization: string[];
    modernization: string[];
    security: string[];
  };
  actionPlan: {
    immediate: string[];
    shortTerm: string[];
    longTerm: string[];
  };
}

async function generateCleanupScript(overview: CodebaseOverview): Promise<string> {
  let script = '#!/bin/bash\n\n';
  script += '# UBOS Codebase Cleanup Script\n';
  script += '# Generated by CodebaseAnalyzer\n\n';

  script += 'echo "ğŸ§¹ Starting UBOS codebase cleanup..."\n\n';

  // Remove unused files
  if (overview.unusedFiles.length > 0) {
    script += '# Remove unused files\n';
    script += 'echo "ğŸ“‚ Removing unused files..."\n';
    
    for (const file of overview.unusedFiles.slice(0, 10)) { // Limit to 10 for safety
      script += `# rm "${file.path}"  # ${file.name} - unused\n`;
    }
    script += '\n';
  }

  // Create organized directory structure
  script += '# Create organized structure\n';
  script += 'echo "ğŸ“ Creating organized directory structure..."\n';
  script += 'mkdir -p src/{core,agents,integrations,utilities,legacy,tests,docs}\n';
  script += 'mkdir -p config\n';
  script += 'mkdir -p scripts\n\n';

  // Move files to appropriate directories
  script += '# Move files to organized locations\n';
  script += 'echo "ğŸ“‹ Organizing files..."\n';
  
  const legacyComponents = overview.components.filter(c => c.status === 'legacy');
  for (const component of legacyComponents.slice(0, 5)) {
    script += `# mv "${component.name}" src/legacy/  # Legacy component\n`;
  }

  script += '\necho "âœ… Cleanup complete!"\n';
  script += 'echo "ğŸ“Š Run analysis again to see improvements"\n';

  return script;
}

async function generateArchitectureMap(overview: CodebaseOverview): Promise<string> {
  let map = '# ğŸ—ï¸ UBOS Architecture Map\n\n';
  map += `**Generated:** ${new Date().toISOString()}\n`;
  map += `**Total Files:** ${overview.totalFiles}\n`;
  map += `**Total Lines:** ${overview.totalLines.toLocaleString()}\n\n`;

  // Core Components
  map += '## ğŸ¯ Core Components\n\n';
  for (const component of overview.architectureMap.core) {
    map += `### ${component.name}\n`;
    map += `- **Status:** ${component.status}\n`;
    map += `- **Usage:** ${component.usage}\n`;
    map += `- **Files:** ${component.files.length}\n`;
    map += `- **Last Activity:** ${component.lastActivity.toDateString()}\n`;
    map += `- **Description:** ${component.description}\n\n`;
  }

  // Agents
  if (overview.architectureMap.agents.length > 0) {
    map += '## ğŸ¤– Agent Components\n\n';
    for (const agent of overview.architectureMap.agents) {
      map += `### ${agent.name}\n`;
      map += `- **Status:** ${agent.status}\n`;
      map += `- **Usage:** ${agent.usage}\n`;
      map += `- **Files:** ${agent.files.length}\n\n`;
    }
  }

  // Integrations
  if (overview.architectureMap.integrations.length > 0) {
    map += '## ğŸ”Œ Integration Components\n\n';
    for (const integration of overview.architectureMap.integrations) {
      map += `### ${integration.name}\n`;
      map += `- **Status:** ${integration.status}\n`;
      map += `- **Usage:** ${integration.usage}\n`;
      map += `- **Files:** ${integration.files.length}\n\n`;
    }
  }

  // Legacy Components
  if (overview.architectureMap.legacy.length > 0) {
    map += '## ğŸ—„ï¸ Legacy Components (Consider for Cleanup)\n\n';
    for (const legacy of overview.architectureMap.legacy) {
      map += `### ${legacy.name}\n`;
      map += `- **Status:** ${legacy.status}\n`;
      map += `- **Last Activity:** ${legacy.lastActivity.toDateString()}\n`;
      map += `- **Files:** ${legacy.files.length}\n`;
      map += `- **âš ï¸ Recommendation:** Review for removal or modernization\n\n`;
    }
  }

  // Languages breakdown
  map += '## ğŸ“Š Technology Stack\n\n';
  const sortedLangs = Object.entries(overview.languages)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 10);

  for (const [lang, count] of sortedLangs) {
    const percentage = ((count / overview.totalFiles) * 100).toFixed(1);
    map += `- **${lang}**: ${count} files (${percentage}%)\n`;
  }

  return map;
}

async function generateDetailedReport(overview: CodebaseOverview): Promise<AnalysisReport> {
  const report: AnalysisReport = {
    overview,
    timestamp: new Date().toISOString(),
    recommendations: {
      cleanup: [],
      organization: [],
      modernization: [],
      security: []
    },
    actionPlan: {
      immediate: [],
      shortTerm: [],
      longTerm: []
    }
  };

  // Generate recommendations
  if (overview.unusedFiles.length > 0) {
    report.recommendations.cleanup.push(`Remove ${overview.unusedFiles.length} unused files`);
    report.actionPlan.immediate.push('Review and remove unused files');
  }

  if (overview.criticalIssues.length > 0) {
    report.recommendations.security.push(`Address ${overview.criticalIssues.length} security issues`);
    report.actionPlan.immediate.push('Fix hardcoded credentials and security issues');
  }

  const legacyCount = overview.architectureMap.legacy.length;
  if (legacyCount > 0) {
    report.recommendations.modernization.push(`Evaluate ${legacyCount} legacy components`);
    report.actionPlan.shortTerm.push('Modernize or remove legacy components');
  }

  const undocumentedCount = overview.components.filter(c => 
    c.files.every(f => !f.path.endsWith('.md'))
  ).length;
  
  if (undocumentedCount > 5) {
    report.recommendations.organization.push('Add documentation for major components');
    report.actionPlan.longTerm.push('Create comprehensive documentation');
  }

  // Organization recommendations
  const rootFiles = overview.components.find(c => c.name === 'Root Files');
  if (rootFiles && rootFiles.files.length > 10) {
    report.recommendations.organization.push('Organize root directory files into proper subdirectories');
    report.actionPlan.shortTerm.push('Restructure root directory');
  }

  return report;
}

async function runAnalysis(): Promise<void> {
  console.log('ğŸš€ Starting UBOS Codebase Analysis...\n');

  try {
    // Run the analysis
    const overview = await codebaseAnalyzer.analyzeCodebase();

    // Generate detailed report
    console.log('ğŸ“ Generating detailed report...');
    const report = await generateDetailedReport(overview);

    // Save analysis results
    const outputDir = path.join(process.cwd(), 'analysis-output');
    await fs.mkdir(outputDir, { recursive: true });

    // Save JSON report
    await fs.writeFile(
      path.join(outputDir, 'codebase-analysis.json'),
      JSON.stringify(report, null, 2),
      'utf-8'
    );

    // Generate architecture map
    console.log('ğŸ—ï¸ Generating architecture map...');
    const architectureMap = await generateArchitectureMap(overview);
    await fs.writeFile(
      path.join(outputDir, 'ARCHITECTURE_MAP.md'),
      architectureMap,
      'utf-8'
    );

    // Generate cleanup script
    console.log('ğŸ§¹ Generating cleanup script...');
    const cleanupScript = await generateCleanupScript(overview);
    await fs.writeFile(
      path.join(outputDir, 'cleanup.sh'),
      cleanupScript,
      'utf-8'
    );

    // Print summary
    console.log('\n' + '='.repeat(60));
    console.log('ğŸ“Š UBOS CODEBASE ANALYSIS COMPLETE');
    console.log('='.repeat(60));
    console.log(`ğŸ“ Total Files: ${overview.totalFiles.toLocaleString()}`);
    console.log(`ğŸ“ Total Lines: ${overview.totalLines.toLocaleString()}`);
    console.log(`ğŸ§© Components: ${overview.components.length}`);
    console.log(`ğŸ—‘ï¸ Unused Files: ${overview.unusedFiles.length}`);
    console.log(`ğŸš¨ Critical Issues: ${overview.criticalIssues.length}`);
    console.log(`ğŸ“‹ Recommendations: ${overview.recommendations.length}`);

    console.log('\nğŸ“ˆ Component Breakdown:');
    console.log(`   ğŸ¯ Core: ${overview.architectureMap.core.length}`);
    console.log(`   ğŸ¤– Agents: ${overview.architectureMap.agents.length}`);
    console.log(`   ğŸ”Œ Integrations: ${overview.architectureMap.integrations.length}`);
    console.log(`   ğŸ› ï¸ Utilities: ${overview.architectureMap.utilities.length}`);
    console.log(`   ğŸ—„ï¸ Legacy: ${overview.architectureMap.legacy.length}`);

    console.log('\nâš¡ Top Priority Actions:');
    for (const action of report.actionPlan.immediate.slice(0, 5)) {
      console.log(`   â€¢ ${action}`);
    }

    console.log(`\nğŸ“‚ Results saved to: ${outputDir}`);
    console.log('   â€¢ codebase-analysis.json - Full analysis data');
    console.log('   â€¢ ARCHITECTURE_MAP.md - Visual overview');
    console.log('   â€¢ cleanup.sh - Automated cleanup script');

    console.log('\nğŸ¯ Next Steps:');
    console.log('   1. Review the architecture map');
    console.log('   2. Run the cleanup script (after review!)');
    console.log('   3. Address critical security issues');
    console.log('   4. Organize files into proper structure');

  } catch (error) {
    console.error('âŒ Analysis failed:', error);
    process.exit(1);
  }
}

// Run analysis if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runAnalysis();
}

export { runAnalysis, generateDetailedReport, generateArchitectureMap };